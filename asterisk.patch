diff -urN a/build_tools/menuselect-deps.in b/build_tools/menuselect-deps.in
--- a/build_tools/menuselect-deps.in
+++ b/build_tools/menuselect-deps.in
@@ -40,6 +40,7 @@ NEON=@PBX_NEON@
 NEON29=@PBX_NEON29@
 OGG=@PBX_OGG@
 OPENH323=@PBX_OPENH323@
+OPUS=@PBX_OPUS@
 OSPTK=@PBX_OSPTK@
 OSS=@PBX_OSS@
 PGSQL=@PBX_PGSQL@
diff -urN a/channels/chan_sip.c b/channels/chan_sip.c
--- a/channels/chan_sip.c
+++ b/channels/chan_sip.c
@@ -7803,8 +7803,25 @@ static int sip_indicate(struct ast_channel *ast, int condition, const void *data
 		break;
 	case AST_CONTROL_VIDUPDATE:	/* Request a video frame update */
 		if (p->vrtp && !p->novideo) {
-			transmit_info_with_vidupdate(p);
-			/* ast_rtcp_send_h261fur(p->vrtp); */
+			/* Only use this for WebRTC users */
+			struct ast_format_cap *fcap = ast_channel_nativeformats(ast);
+			struct ast_format vp8;
+			ast_format_set(&vp8, AST_FORMAT_VP8, 0);
+			if (ast_format_cap_iscompatible(fcap, &vp8)) {
+				sip_pvt_lock(p);
+				if (p->vrtp) {
+					struct ast_frame fr;
+					ast_log(LOG_WARNING, "chan_sip, sending RTCP FIR to WebRTC user\n");
+					/* FIXME Fake RTP write, this will be sent as an RTCP packet */
+					fr.frametype = AST_FRAME_CONTROL;
+					fr.subclass.integer = AST_CONTROL_VIDUPDATE;
+					res = ast_rtp_instance_write(p->vrtp, &fr);
+				}
+				sip_pvt_unlock(p);
+			} else {
+				transmit_info_with_vidupdate(p);
+				/* ast_rtcp_send_h261fur(p->vrtp); */
+			}
 		} else
 			res = -1;
 		break;
@@ -11119,7 +11136,7 @@ static int process_sdp_a_audio(const char *a, struct sip_pvt *p, struct ast_rtp_
 		struct ast_format *format;
 
 		if ((format = ast_rtp_codecs_get_payload_format(newaudiortp, codec))) {
-			unsigned int bit_rate;
+			unsigned int bit_rate, value;
 
 			if (!ast_format_sdp_parse(format, fmtp_string)) {
 				found = TRUE;
@@ -11158,6 +11175,54 @@ static int process_sdp_a_audio(const char *a, struct sip_pvt *p, struct ast_rtp_
 					}
 				}
 				break;
+			/* Opus SDP fmtp parameters (draft-ietf-payload-rtp-opus-00) */
+			case AST_FORMAT_OPUS:
+				if (sscanf(fmtp_string, "maxplaybackrate=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus maxplaybackrate=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "sprop-maxcapturerate=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus sprop-maxplaybackrate=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "minptime=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus minptime=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "maxaveragebitrate=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus maxaveragebitrate=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "stereo=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus stereo=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "sprop-stereo=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus sprop-stereo=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "cbr=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus cbr=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "useinbandfec=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus useinbandfec=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				if (sscanf(fmtp_string, "usedtx=%30u", &value) == 1) {
+					ast_log(LOG_WARNING, "Got Opus usedtx=%d\n", value);
+					/* TODO: actually handle this */
+					found = TRUE;
+				}
+				break;
 			}
 		}
 	}
@@ -11178,7 +11243,9 @@ static int process_sdp_a_video(const char *a, struct sip_pvt *p, struct ast_rtp_
 		/* We have a rtpmap to handle */
 		if (*last_rtpmap_codec < SDP_MAX_RTPMAP_CODECS) {
 			/* Note: should really look at the '#chans' params too */
-			if (!strncasecmp(mimeSubtype, "H26", 3) || !strncasecmp(mimeSubtype, "MP4", 3)) {
+			if (!strncasecmp(mimeSubtype, "H26", 3)
+				|| !strncasecmp(mimeSubtype, "MP4", 3)
+				|| !strncasecmp(mimeSubtype, "VP8", 3)) {
 				if (!(ast_rtp_codecs_payloads_set_rtpmap_type_rate(newvideortp, NULL, codec, "video", mimeSubtype, 0, sample_rate))) {
 					if (debug)
 						ast_verbose("Found video description format %s for ID %d\n", mimeSubtype, codec);
@@ -12751,7 +12818,12 @@ static void add_codec_to_sdp(const struct sip_pvt *p,
 	} else /* I don't see how you couldn't have p->rtp, but good to check for and error out if not there like earlier code */
 		return;
 	ast_str_append(m_buf, 0, " %d", rtp_code);
-	ast_str_append(a_buf, 0, "a=rtpmap:%d %s/%d\r\n", rtp_code, mime, rate);
+
+	if ((int) format->id == AST_FORMAT_OPUS) {
+		ast_str_append(a_buf, 0, "a=rtpmap:%d %s/%d/2\r\n", rtp_code, mime, rate);
+	} else {
+		ast_str_append(a_buf, 0, "a=rtpmap:%d %s/%d\r\n", rtp_code, mime, rate);
+	}
 
 	ast_format_sdp_generate(format, rtp_code, a_buf);
 
@@ -12780,6 +12852,16 @@ static void add_codec_to_sdp(const struct sip_pvt *p,
 		/* Indicate that we only expect 64Kbps */
 		ast_str_append(a_buf, 0, "a=fmtp:%d bitrate=64000\r\n", rtp_code);
 		break;
+	case AST_FORMAT_OPUS:
+		ast_str_append(a_buf, 0, "a=maxptime:%d\r\n", 60); /* FIXME */
+		ast_str_append(a_buf, 0, "a=fmtp:%d maxplaybackrate=%d; stereo=%d; sprop-stereo=%d; useinbandfec=%d\r\n",
+			rtp_code,
+			16000, /* maxplaybackrate */
+			0,     /* stereo */
+			0,     /* sprop-stereo */
+			0      /* useinbandfec FIXME */
+			);
+		break;
 	}
 
 	if (fmt.cur_ms && (fmt.cur_ms < *min_packet_size))
diff -urN a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -422,6 +422,7 @@ AST_EXT_LIB_SETUP([NETSNMP], [Net-SNMP], [netsnmp])
 AST_EXT_LIB_SETUP([NEWT], [newt], [newt])
 AST_EXT_LIB_SETUP([OGG], [OGG], [ogg])
 AST_EXT_LIB_SETUP([OPENR2], [MFR2], [openr2])
+AST_EXT_LIB_SETUP([OPUS], [Opus], [opus])
 AST_EXT_LIB_SETUP([OSPTK], [OSP Toolkit], [osptk])
 AST_EXT_LIB_SETUP([OSS], [Open Sound System], [oss])
 AST_EXT_LIB_SETUP([PGSQL], [PostgreSQL], [postgres])
@@ -2147,6 +2148,8 @@ fi
 
 AC_SUBST(PBX_SPEEX_PREPROCESS)
 
+AST_EXT_LIB_CHECK([OPUS], [opus], [opus_encoder_create], [opus/opus.h])
+
 AST_EXT_LIB_CHECK([SQLITE], [sqlite], [sqlite_exec], [sqlite.h])
 
 AST_EXT_LIB_CHECK([SQLITE3], [sqlite3], [sqlite3_open], [sqlite3.h], [${PTHREAD_LIBS}], [${PTHREAD_CFLAGS}])
diff -urN a/include/asterisk/format.h b/include/asterisk/format.h
--- a/include/asterisk/format.h
+++ b/include/asterisk/format.h
@@ -101,6 +101,8 @@ enum ast_format_id {
 	AST_FORMAT_SLINEAR192       = 27 + AST_FORMAT_TYPE_AUDIO,
 	AST_FORMAT_SPEEX32          = 28 + AST_FORMAT_TYPE_AUDIO,
 	AST_FORMAT_CELT             = 29 + AST_FORMAT_TYPE_AUDIO,
+	/*! Opus */
+	AST_FORMAT_OPUS             = 30 + AST_FORMAT_TYPE_AUDIO,
 
 	/*! H.261 Video */
 	AST_FORMAT_H261             = 1 + AST_FORMAT_TYPE_VIDEO,
@@ -112,6 +114,8 @@ enum ast_format_id {
 	AST_FORMAT_H264             = 4 + AST_FORMAT_TYPE_VIDEO,
 	/*! MPEG4 Video */
 	AST_FORMAT_MP4_VIDEO        = 5 + AST_FORMAT_TYPE_VIDEO,
+	/*! VP8 */
+	AST_FORMAT_VP8              = 6 + AST_FORMAT_TYPE_VIDEO,
 
 	/*! JPEG Images */
 	AST_FORMAT_JPEG             = 1 + AST_FORMAT_TYPE_IMAGE,
diff -urN a/main/channel.c b/main/channel.c
--- a/main/channel.c
+++ b/main/channel.c
@@ -914,6 +914,8 @@ struct ast_format *ast_best_codec(struct ast_format_cap *cap, struct ast_format
 		AST_FORMAT_SPEEX32,
 		AST_FORMAT_SPEEX16,
 		AST_FORMAT_SPEEX,
+		/*! Opus */
+		AST_FORMAT_OPUS,
 		/*! SILK is pretty awesome. */
 		AST_FORMAT_SILK,
 		/*! CELT supports crazy high sample rates */
diff -urN a/main/format.c b/main/format.c
--- a/main/format.c
+++ b/main/format.c
@@ -430,6 +430,9 @@ uint64_t ast_format_id_to_old_bitfield(enum ast_format_id id)
 	/*! SpeeX Wideband (16kHz) Free Compression */
 	case AST_FORMAT_SPEEX16:
 		return (1ULL << 33);
+	/*! Opus audio (8kHz, 16kHz, 24kHz, 48Khz) */
+	case AST_FORMAT_OPUS:
+		return (1ULL << 34);
 	/*! Raw mu-law data (G.711) */
 	case AST_FORMAT_TESTLAW:
 		return (1ULL << 47);
@@ -449,6 +452,9 @@ uint64_t ast_format_id_to_old_bitfield(enum ast_format_id id)
 	/*! MPEG4 Video */
 	case AST_FORMAT_MP4_VIDEO:
 		return (1ULL << 22);
+	/*! VP8 Video */
+	case AST_FORMAT_VP8:
+		return (1ULL << 23);
 
 	/*! JPEG Images */
 	case AST_FORMAT_JPEG:
@@ -532,6 +538,9 @@ struct ast_format *ast_format_from_old_bitfield(struct ast_format *dst, uint64_t
 	/*! SpeeX Wideband (16kHz) Free Compression */
 	case (1ULL << 33):
 		return ast_format_set(dst, AST_FORMAT_SPEEX16, 0);
+	/*! Opus audio (8kHz, 16kHz, 24kHz, 48Khz) */
+	case (1ULL << 34):
+		return ast_format_set(dst, AST_FORMAT_OPUS, 0);
 	/*! Raw mu-law data (G.711) */
 	case (1ULL << 47):
 		return ast_format_set(dst, AST_FORMAT_TESTLAW, 0);
@@ -551,6 +560,9 @@ struct ast_format *ast_format_from_old_bitfield(struct ast_format *dst, uint64_t
 	/*! MPEG4 Video */
 	case (1ULL << 22):
 		return ast_format_set(dst, AST_FORMAT_MP4_VIDEO, 0);
+	/*! VP8 Video */
+	case (1ULL << 23):
+		return ast_format_set(dst, AST_FORMAT_VP8, 0);
 
 	/*! JPEG Images */
 	case (1ULL << 16):
@@ -782,6 +794,8 @@ int ast_format_rate(const struct ast_format *format)
 			return samplerate;
 		}
 	}
+	case AST_FORMAT_OPUS:
+		return 48000;
 	default:
 		return 8000;
 	}
@@ -1071,6 +1085,10 @@ static int format_list_init(void)
 	format_list_add_static(ast_format_set(&tmpfmt, AST_FORMAT_SLINEAR48, 0), "slin48", 48000, "16 bit Signed Linear PCM (48kHz)", 960, 10, 70, 10, 20, AST_SMOOTHER_FLAG_BE, 0);/*!< Signed linear (48kHz) */
 	format_list_add_static(ast_format_set(&tmpfmt, AST_FORMAT_SLINEAR96, 0), "slin96", 96000, "16 bit Signed Linear PCM (96kHz)", 1920, 10, 70, 10, 20, AST_SMOOTHER_FLAG_BE, 0);/*!< Signed linear (96kHz) */
 	format_list_add_static(ast_format_set(&tmpfmt, AST_FORMAT_SLINEAR192, 0), "slin192", 192000, "16 bit Signed Linear PCM (192kHz)", 3840, 10, 70, 10, 20, AST_SMOOTHER_FLAG_BE, 0);/*!< Signed linear (192kHz) */
+	/* Opus (FIXME: real min is 3/5/10, real max is 120...) */
+	format_list_add_static(ast_format_set(&tmpfmt, AST_FORMAT_OPUS, 0), "opus", 48000, "Opus Codec", 10, 20, 60, 20, 20, 0, 0);/*!< codec_opus.c */
+	/* VP8 (passthrough) */
+	format_list_add_static(ast_format_set(&tmpfmt, AST_FORMAT_VP8, 0), "vp8", 0, "VP8 Video", 0, 0, 0, 0 ,0 ,0, 0);/*!< Passthrough support, see format_h263.c */
 
 	return 0;
 }
diff -urN a/main/frame.c b/main/frame.c
--- a/main/frame.c
+++ b/main/frame.c
@@ -1002,6 +1002,49 @@ static int speex_samples(unsigned char *data, int len)
 	return cnt;
 }
 
+/* Opus: copied from opus_decoder.c */
+static int opus_samples(unsigned char *data, int len)
+{
+	int count, frames;
+
+	/* Do opus_packet_get_nb_frames first */
+	if (len < 1) {
+		/* FIXME OPUS_BAD_ARG */
+		return 0;
+	} else {
+		count = data[0] & 0x3;
+		if (count == 0) {
+			frames = 1;
+		} else if (count != 3) {
+			frames = 2;
+		} else if (len < 2) {
+			/* FIXME OPUS_INVALID_PACKET */
+			return 0;
+		} else {
+			frames = data[1] & 0x3F;
+		}
+	}
+
+	/* Then, do a opus_packet_get_samples_per_frame */
+	int audiosize, Fs = 48000;
+
+	if (data[0] & 0x80) {
+		audiosize = ((data[0] >> 3) & 0x3);
+		audiosize = (Fs << audiosize) / 400;
+	} else if ((data[0] & 0x60) == 0x60) {
+		audiosize = (data[0] & 0x08) ? Fs / 50 : Fs / 100;
+	} else {
+		audiosize = ((data[0] >> 3) & 0x3);
+		if (audiosize == 3) {
+			audiosize = Fs * 60 / 1000;
+		} else {
+			audiosize = (Fs << audiosize) / 100;
+		}
+	}
+
+	return frames * audiosize;
+}
+
 int ast_codec_get_samples(struct ast_frame *f)
 {
 	int samples = 0;
@@ -1083,6 +1126,9 @@ int ast_codec_get_samples(struct ast_frame *f)
 		/* TODO The assumes 20ms delivery right now, which is incorrect */
 		samples = ast_format_rate(&f->subclass.format) / 50;
 		break;
+	case AST_FORMAT_OPUS:
+		samples = opus_samples(f->data.ptr, f->datalen);
+		break;
 	default:
 		ast_log(LOG_WARNING, "Unable to calculate samples for format %s\n", ast_getformatname(&f->subclass.format));
 	}
diff -urN a/main/rtp_engine.c b/main/rtp_engine.c
--- a/main/rtp_engine.c
+++ b/main/rtp_engine.c
@@ -2309,6 +2309,8 @@ int ast_rtp_engine_init()
 	set_next_mime_type(ast_format_set(&tmpfmt, AST_FORMAT_SIREN7, 0), 0, "audio", "G7221", 16000);
 	set_next_mime_type(ast_format_set(&tmpfmt, AST_FORMAT_SIREN14, 0), 0, "audio", "G7221", 32000);
 	set_next_mime_type(ast_format_set(&tmpfmt, AST_FORMAT_G719, 0), 0, "audio", "G719", 48000);
+	set_next_mime_type(ast_format_set(&tmpfmt, AST_FORMAT_OPUS, 0), 0,  "audio", "opus", 48000);
+	set_next_mime_type(ast_format_set(&tmpfmt, AST_FORMAT_VP8, 0), 0,  "video", "VP8", 90000);
 
 	/* Define the static rtp payload mappings */
 	add_static_payload(0, ast_format_set(&tmpfmt, AST_FORMAT_ULAW, 0), 0);
@@ -2350,6 +2352,8 @@ int ast_rtp_engine_init()
 	add_static_payload(118, ast_format_set(&tmpfmt, AST_FORMAT_SLINEAR16, 0), 0); /* 16 Khz signed linear */
 	add_static_payload(119, ast_format_set(&tmpfmt, AST_FORMAT_SPEEX32, 0), 0);
 	add_static_payload(121, NULL, AST_RTP_CISCO_DTMF);   /* Must be type 121 */
+	add_static_payload(100, ast_format_set(&tmpfmt, AST_FORMAT_VP8, 0), 0);
+	add_static_payload(107, ast_format_set(&tmpfmt, AST_FORMAT_OPUS, 0), 0);
 
 	return 0;
 }
diff -urN a/makeopts.in b/makeopts.in
--- a/makeopts.in
+++ b/makeopts.in
@@ -262,6 +262,9 @@ SPEEX_LIB=@SPEEX_LIB@
 SPEEXDSP_INCLUDE=@SPEEXDSP_INCLUDE@
 SPEEXDSP_LIB=@SPEEXDSP_LIB@
 
+OPUS_INCLUDE=@OPUS_INCLUDE@
+OPUS_LIB=@OPUS_LIB@
+
 SQLITE_INCLUDE=@SQLITE_INCLUDE@
 SQLITE_LIB=@SQLITE_LIB@
 
diff -urN a/res/res_rtp_asterisk.c b/res/res_rtp_asterisk.c
--- a/res/res_rtp_asterisk.c
+++ b/res/res_rtp_asterisk.c
@@ -95,6 +95,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 #define RTCP_PT_SDES    202
 #define RTCP_PT_BYE     203
 #define RTCP_PT_APP     204
+#define RTCP_PT_PSFB    206 /*!< VP8: RTCP Feedback */
 
 #define RTP_MTU		1200
 #define DTMF_SAMPLE_RATE_MS    8 /*!< DTMF samples per millisecond */
@@ -356,6 +357,7 @@ struct ast_rtcp {
 	double normdevrtt;
 	double stdevrtt;
 	unsigned int rtt_count;
+	int firseq; /*!< VP8: sequence number for the RTCP FIR FCI */
 };
 
 struct rtp_red {
@@ -2798,6 +2800,52 @@ static int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *fr
 		return 0;
 	}
 
+	/* VP8: is this a request to send a RTCP FIR? */
+	if (frame->frametype == AST_FRAME_CONTROL && frame->subclass.integer == AST_CONTROL_VIDUPDATE) {
+		struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+		unsigned int *rtcpheader;
+		char bdata[1024];
+		int res, ice, len = 20;
+
+		ast_debug(3, "Requested to send a RTCP FIR packet to the peer\n");
+
+		if (!rtp || !rtp->rtcp) {
+			return 0;
+		}
+
+		if (ast_sockaddr_isnull(&rtp->rtcp->them)) {
+			/* RTCP was stopped */
+			return 0;
+		}
+
+		/* Prepare RTCP FIR (PT=206, FMT=4) */
+		rtp->rtcp->firseq++;
+		if (rtp->rtcp->firseq == 256) {
+			rtp->rtcp->firseq = 0;
+		}
+
+		rtcpheader = (unsigned int *) bdata;
+		rtcpheader[0] = htonl((2 << 30) | (4 << 24) | (RTCP_PT_PSFB << 16) | ((len / 4)-1));
+		rtcpheader[1] = htonl(rtp->ssrc);
+		rtcpheader[2] = htonl(rtp->themssrc);
+
+		/* FCI: SSRC */
+		rtcpheader[3] = htonl(rtp->themssrc);
+
+		/* FCI: Sequence number */
+		rtcpheader[4] = htonl(rtp->rtcp->firseq << 24);
+
+		res = rtcp_sendto(instance, (unsigned int *)rtcpheader, len, 0, &rtp->rtcp->them, &ice);
+		if (res < 0) {
+			ast_log(LOG_ERROR, "RTCP FIR transmission error: %s\n", strerror(errno));
+			return 0;
+		}
+
+		ast_debug(3, "RTCP FIR packet sent to the peer\n");
+
+		return 0;
+	}
+
 	/* If there is no data length we can't very well send the packet */
 	if (!frame->datalen) {
 		ast_debug(1, "Received frame with no data for RTP instance '%p' so dropping frame\n", instance);
@@ -2849,6 +2897,7 @@ static int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *fr
 		case AST_FORMAT_SIREN7:
 		case AST_FORMAT_SIREN14:
 		case AST_FORMAT_G719:
+		case AST_FORMAT_OPUS:
 			/* these are all frame-based codecs and cannot be safely run through
 			   a smoother */
 			break;
